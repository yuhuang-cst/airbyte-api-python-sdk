"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import json
import requests as requests_http
from airbyte import utils
from airbyte.web_backend_models import operations, shared
from typing import Optional

class WebBackend:
    r"""Endpoints for the Airbyte web application. Those APIs should not be called outside the web application implementation and are not
    guaranteeing any backwards compatibility.
    """
    _client: requests_http.Session
    _security_client: requests_http.Session
    _server_url: str
    _language: str
    _sdk_version: str
    _gen_version: str

    def __init__(self, client: requests_http.Session, security_client: requests_http.Session, server_url: str, language: str, sdk_version: str, gen_version: str) -> None:
        self._client = client
        self._security_client = security_client
        self._server_url = server_url
        self._language = language
        self._sdk_version = sdk_version
        self._gen_version = gen_version
        
    
    def get_state_type(self, request: shared.ConnectionIDRequestBody) -> operations.GetStateTypeResponse:
        r"""Fetch the current state type for a connection."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/v1/web_backend/state/get_type'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, shared.ConnectionIDRequestBody, "request", True, True, 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.GetStateTypeResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.ConnectionStateTypeEnum])
                res.connection_state_type = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.NotFoundKnownExceptionInfo])
                res.not_found_known_exception_info = out
        elif http_res.status_code == 422:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.InvalidInputExceptionInfo])
                res.invalid_input_exception_info = out

        return res

    
    def web_backend_check_updates(self) -> operations.WebBackendCheckUpdatesResponse:
        r"""Returns a summary of source and destination definitions that could be updated."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/v1/web_backend/check_updates'
        
        
        client = self._client
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.WebBackendCheckUpdatesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.WebBackendCheckUpdatesRead])
                res.web_backend_check_updates_read = out

        return res

    
    def web_backend_create_connection(self, request: shared.WebBackendConnectionCreate) -> operations.WebBackendCreateConnectionResponse:
        r"""Create a connection"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/v1/web_backend/connections/create'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, shared.WebBackendConnectionCreate, "request", True, True, 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.WebBackendCreateConnectionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.WebBackendConnectionRead])
                res.web_backend_connection_read = out
        elif http_res.status_code == 422:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.InvalidInputExceptionInfo])
                res.invalid_input_exception_info = out

        return res

    
    def web_backend_get_connection(self, request: shared.WebBackendConnectionRequestBody) -> operations.WebBackendGetConnectionResponse:
        r"""Get a connection"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/v1/web_backend/connections/get'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, shared.WebBackendConnectionRequestBody, "request", True, True, 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.WebBackendGetConnectionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.WebBackendConnectionRead])
                res.web_backend_connection_read = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.NotFoundKnownExceptionInfo])
                res.not_found_known_exception_info = out
        elif http_res.status_code == 422:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.InvalidInputExceptionInfo])
                res.invalid_input_exception_info = out

        return res

    
    def web_backend_get_workspace_state(self, request: shared.WebBackendWorkspaceState) -> operations.WebBackendGetWorkspaceStateResponse:
        r"""Returns the current state of a workspace"""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/v1/web_backend/workspace/state'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, shared.WebBackendWorkspaceState, "request", True, True, 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        
        client = self._client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.WebBackendGetWorkspaceStateResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.WebBackendWorkspaceStateResult])
                res.web_backend_workspace_state_result = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.NotFoundKnownExceptionInfo])
                res.not_found_known_exception_info = out
        elif http_res.status_code == 422:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.InvalidInputExceptionInfo])
                res.invalid_input_exception_info = out

        return res

    
    def web_backend_list_connections_for_workspace(self, request: shared.WebBackendConnectionListRequestBody) -> operations.WebBackendListConnectionsForWorkspaceResponse:
        r"""Returns all non-deleted connections for a workspace."""
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/v1/web_backend/connections/list'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, shared.WebBackendConnectionListRequestBody, "request", True, True, 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.WebBackendListConnectionsForWorkspaceResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.WebBackendConnectionReadList])
                res.web_backend_connection_read_list = out
        elif http_res.status_code == 404:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.NotFoundKnownExceptionInfo])
                res.not_found_known_exception_info = out
        elif http_res.status_code == 422:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.InvalidInputExceptionInfo])
                res.invalid_input_exception_info = out

        return res

    
    def web_backend_list_geographies(self) -> operations.WebBackendListGeographiesResponse:
        r"""Returns available geographies can be selected to run data syncs in a particular geography.
        The 'auto' entry indicates that the sync will be automatically assigned to a geography according
        to the platform default behavior. Entries other than 'auto' are two-letter country codes that
        follow the ISO 3166-1 alpha-2 standard.
        Returns all available geographies in which a data sync can run.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/v1/web_backend/geographies/list'
        
        
        client = self._client
        
        http_res = client.request('POST', url)
        content_type = http_res.headers.get('Content-Type')

        res = operations.WebBackendListGeographiesResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.WebBackendGeographiesListResult])
                res.web_backend_geographies_list_result = out

        return res

    
    def web_backend_update_connection(self, request: shared.WebBackendConnectionUpdate) -> operations.WebBackendUpdateConnectionResponse:
        r"""Update a connection
        Apply a patch-style update to a connection. Only fields present on the update request body will be updated.
        Any operations that lack an ID will be created. Then, the newly created operationId will be applied to the
        connection along with the rest of the operationIds in the request body.
        Apply a patch-style update to a connection. Only fields present on the update request body will be updated.
        Note that if a catalog is present in the request body, the connection's entire catalog will be replaced
        with the catalog from the request. This means that to modify a single stream, the entire new catalog
        containing the updated stream needs to be sent.
        """
        base_url = self._server_url
        
        url = base_url.removesuffix('/') + '/v1/web_backend/connections/update'
        
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, shared.WebBackendConnectionUpdate, "request", True, True, 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        
        client = self._client
        
        http_res = client.request('POST', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')

        res = operations.WebBackendUpdateConnectionResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.WebBackendConnectionRead])
                res.web_backend_connection_read = out
        elif http_res.status_code == 422:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[shared.InvalidInputExceptionInfo])
                res.invalid_input_exception_info = out

        return res


    def web_backend_discover_schema(self, source_id, disable_cache: bool=True):
        base_url = self._server_url
        url = base_url.removesuffix('/') + '/v1/sources/discover_schema'
        client = self._client
        headers = {
            'content-type': 'application/json'
        }
        data = {
            'sourceId': source_id,
            'disable_cache': disable_cache,
        }
        http_res = client.request('POST', url, headers=headers, data=json.dumps(data))
        return http_res
